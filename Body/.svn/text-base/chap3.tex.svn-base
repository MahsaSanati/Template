
\chapter{A generic motif discovery algorithm}

\begin{comment}
\textbf{Motivation:}
Motif discovery in sequential data is a problem of great
interest and with many applications.  However, previous methods
have been unable to combine exhaustive search with
complex motif representations and are each
typically only applicable to a certain class of problems.

\textbf{Results:}
Here we present a GEneric MOtif DIscovery Algorithm
(Gemoda) for sequential data.  Gemoda can be applied to any
dataset with a sequential character, including both categorical
and real--valued data.  As we show,
Gemoda deterministically discovers motifs that are maximal
in composition and length.  As well, the algorithm allows any
choice of similarity metric for finding motifs.  Finally,
Gemoda's output motifs are representation--agnostic:
they can be represented using regular expressions,
position weight matrices, or any number of other models for any
type of sequential data.
We demonstrate a number
of applications of the algorithm, including the discovery
of motifs in amino acids sequences, a new solution to the
(l,d)--motif problem in DNA sequences, and the discovery of
conserved protein sub--structures.

\textbf{Availability:}
Gemoda is freely available at \url{http://web.mit.edu/bamel/gemoda}.

\textbf{Contact:}
gregstep@mit.edu

\textbf{Supplementary Information:} 
Available at \url{http://web.mit.edu/bamel/gemoda}.
\end{comment}


\section{Introduction}

Motif discovery encompasses a wide variety of methods used
to find recurrent trends in data.
In bioinformatics, the two predominant applications of
motif discovery are sequence analysis and microarray
data analysis.  Less common applications include
discovering structural motifs in proteins and
RNA~\citep{holm1992database,murthy2003rnabase}. \index{protein!structure}

Motif discovery in sequence analysis typically
involves the discovery of binding sites, conserved
domains, or otherwise discriminatory subsequences.
There are many publicly--available tools, each of which is
quite adept at addressing a specific subclass of motif
discovery problems.  Some of the commonly-used
tools for motif discovery in nucleotide and amino acid
sequences include MEME~\citep{bailey1994fitting},
Gibbs sampling~\citep{lawrence1993detecting},
Consensus~\citep{hertz1999identifying},
Block Maker~\citep{henikoff1995automated},
Pratt~\citep{jonassen1995finding}, and
Teiresias~\citep{rigoutsos1998combinatorial}.
Newer, less-widely used tools
include Projection~\citep{buhler2001finding},
MultiProfiler~\citep{keich2002finding},
MITRA~\citep{eskin2002finding}, and
ProfileBranching~\citep{price2003finding}.  This list
is not intended to be exhaustive; however, it is
indicative of the wealth of options available for solving
such problems.

All of the existing motif discovery tools for nucleotide
and amino acid sequences can be classified on a spectrum
ranging from exhaustive tools using simple motif
representations to non--exhaustive tools using more
complex representations.  The majority of the tools can
be found at the extreme ends of the spectrum, with tools
that exhaustively enumerate regular expressions (or single
consensus sequences) at one end and probabilistic tools,
based on position weight matrices (PWMs), at the other.
This partitioning of tools is due to a computational
trade--off: more descriptive motif representations such as
PWMs frequently make exhaustive searches computationally
infeasible.

Depending on the task at hand, a specific type
of motif discovery tool may be more useful
than others.  For example, the PWM--based tools
excel at finding \textit{cis}--regulatory binding
elements~\citep{tompa2005assessing}, whereas the
regular expression--based tools are well--suited
to finding conserved domains in large protein
families~\citep{rigoutsos1999dictionary}.  Generally,
it can be difficult to know \textit{a priori} which motif
discovery tool will be right.



\section{Algorithm}

    Gemoda was designed to meet the demand for complex
    motif representations, like PWMs, while still
    being exhaustive.  The philosophical underpinnings
    of the Gemoda algorithm can be traced back to
    Teiresias~\citep{rigoutsos1998combinatorial};
    Winnower~\citep{pevzner2000combinatorial}; the
    algorithm by~\citep{mancheron2003pattern}; and
    a variety of algorithms for association
    mining~\citep{zaki2000scalable,zaki1998theoretical}.
    In particular, Gemoda shares some of its logical steps
    with the Teiresias algorithm while incorporating a
    more flexible definition of ``similarity'' and allowing
    motif representations other than regular expressions.

    Gemoda's design goals can be summarized
    as follows: \emph{exhaustive discovery} of all
    \emph{maximal motifs} in a way that allows
    flexibility in \emph{motif representation},
    incorporation of a variety of
    \emph{similarity metrics}, and the ability to handle
    diverse \emph{sequential
    data types}.  Each point of emphasis can be explained
    as follows:
	    \begin{itemize}

		\item\textbf{Exhaustive discovery:} Gemoda's combinatorial
		    nature provides an algorithmic
		    guarantee that all motifs meeting
		    certain criteria are deterministically
		    discovered. 

		\item\textbf{Maximal motifs:} Gemoda
		    returns only motifs that are maximal
		    in both length and composition with respect
		    to the similarity and clustering functions.


		\item\textbf{Motif representation:}  The motifs
		    discovered by Gemoda are reported as
		    short multiple
		    sequence alignments (in the case of
		    motif discovery in nucleotide and amino
		    acid sequences) and can be
		    modeled using regular expressions,
		    PWMs/PSSMs, Markov models, or any
		    other representation.

		\item\textbf{Similarity metrics:} Any criterion, ranging
		    from sequence alignment scores to
		    geometric functions, may be used to
		    compare sequences. 

		\item\textbf{Sequential data types:} The
		    nature of Gemoda's computations is not
		    unique to any specific type of data,
		    and thus can be used on any data with
		    a sequential character --- that is,
		    data in which there is a natural
		    left--to--right order, such as a
		    sequence of nucleotides or amino acids.
		    In the most general sense, sequential data
		    also include real--valued series data,
		    such as a stock price or the ordered
		    $(x,y,z)$ triplets of an alpha--carbon
		    trace in a protein structure.



	    \end{itemize}

    The algorithm has three distinct phases:
    comparison, clustering, and convolution.  During the
    comparison phase, short overlapping windows in the data
    set are compared.  During clustering, these windows
    are grouped together to form elementary motifs.  
    Finally, during convolution, these motifs
    are ``stitched'' together to form maximal motifs (see
    Figure~\vref{fig:gemoda}).  In the following sections,
    we give some brief definitions and nomenclature,
    then describe each of the algorithm's three phases
    in detail.  Finally, we illustrate a few applications
    of Gemoda.


	\begin{sidewaysfigure}[phtb]
	    \centering
	    \includegraphics[width=\textheight]{Body/Images-chap3/gemoda_fig5.pdf}
	    \caption{A sketch showing the flow of the Gemoda algorithm
		    for an example input set of protein sequences.
		    The various colors in the input sequences are used
		    to indicate the sequential ordering of the $L$--residue
		    windows.  The various shapes are used to indicate
		    a particular window's sequence of origin.  (1) In the
		    comparison stage, each window is compared to each
		    other window on a pair--wise basis.  Here we show
		    the similarity matrix, $A$, where the values in the
		    matrix have been thresholded.  Those pairs of windows
		    in $A$ that have a similarity score above the threshold
		    are colored black.  Note that the graph looks very
		    similar to a standard dot plot.  (2) In the clustering 
		    phase, groups of windows are clustered together.
		    Here, we show the clusters as cliques, or maximal
		    fully--connected subgraphs in the thresholded matrix
		    $A$.  (3) Finally, these clustered are ``stitched'' together
		    in the convolution phase using the sequential ordering
		    of the windows to reveal the maximal motifs.
		    A similar process
		    applies for any kind of sequential data analyzed by
		    Gemoda.
		}\label{fig:gemoda}
	\end{sidewaysfigure}

    \subsection{Preliminary definitions and nomenclature}

	The input to Gemoda is a set of sequences of
	data points $S=\braces{s_1,s_2,\ldots,s_n}$, where
	sequence $s_i$ has length $W_i$.  So, for example,
	the $\ith{j}$ member of the $\ith{i}$ sequence
	is denoted by $s_{i,j}$.  Each $s_{i,j}$ is a
	primitive, or atomic unit, for the data that is
	being analyzed.  For time--series data, $s_{i,j}$
	may be a point sampled from $\realNums^{K}$ (with
	$K$ arbitrary), whereas for a DNA sequence it would
	be one of the characters $\{\texttt{A,T,G,C}\}$.

	Typically, one seeks motifs
	of a minimal, domain--dependent length.
	We denote this minimum length by $L$
	and we define a matrix $A$ of size
	$N\times N$, where $N = \sum_{i=1}^{n}(W_i-L+1)$.
	That is, $A$ is a matrix with one row and one column for each
	window of size $L$ in our entire sequence set.
	For example, the $10^{th}$ window of size $L$ in the $5^{th}$
	sequence would be expressed as $s_{5,10:10+L-1}$,
	where ``$10:10+L-1$'' denotes ``position $10$
	through position $10+L-1$, inclusive.''  To keep
	track of which window corresponds to which index
	in $A$, we define the one--to--one function
	$\mathscr{M}(s_{i,j:j+L-1})\mapsto q \in [1,N]$.
	(For simplicity, we define
	$(s_{i,j}+1)$ to be $s_{i,j+1}$, unless $s_{i,j+1}$
	does not exist, in which case $(s_{i,j}+1)$
	is undefined.)	Similarly, $\mathscr{M}^{-1}(q)
	\mapsto (s_{i,j:j+L-1})$ such that $i\in[1,n]$
	and $j \in [1,W_i-L+1]$.

	We also define a similarity function
	$\mathscr{S}(s_{i,j:j+L-1}, s_{q,z:z+L-1})$,
	that takes as arguments two
	arbitrary windows and returns a real--valued number
	indicating the level of similarity between the two
	windows.  In the most simple case, $\mathscr{S}$
	may use the identity matrix to count how
	many DNA bases two windows have in common;
	for real--valued data, the function may return
	the sum--of--squares error between two windows
	or any other measure of similarity.

	We define a motif $p$ as a data structure
	with two features: a width $\mathscr{W}(p)$
	and a list of locations in the data where the
	motif occurs, $\mathscr{L}(p)$.  A motif has the
	property that the locations in $\mathscr{L}(p)$
	meet some predefined clustering requirements
	(discussed below) based on the similarity function
	$\mathscr{S}$ for each window of length $L$ within
	the motif.  The support of a motif is equal to
	the number of its occurrences (or ``embeddings''),
	$\vert \mathscr{L}(p) \vert$.

	We say a maximal motif is a motif which has the following properties:
	    \begin{enumerate}
		\item	The motif's width cannot be extended in
			either direction (left or right)
			without producing a motif with
			fewer embeddings (i.e., without
			$\vert \mathscr{L}(p) \vert$
			decreasing); and

		\item   The motif is not missing any instances,
			i.e.\ $\mathscr{L}(p)$ includes the locations
			of all instances of the motif.

	    \end{enumerate}
	These two criteria can be summarized qualitatively by stating that a maximal
	motif is not ``missing'' any locations and is as wide as possible, and
	thus it is as specific and sensitive as possible.

	Given these explanations and definitions, we can now detail
	the computations involved in each phase of the Gemoda algorithm.
	A simple natural--language example illustrating how each phase
	proceeds is included in the supplementary materials.

    \subsection{Comparison phase}
	In the comparison phase of the Gemoda algorithm,
	the sequences are divided into overlapping windows
	of size $L$ which are then compared to each other
	in a pairwise manner to produce a similarity
	matrix, $A$ (see Figure~\vref{fig:gemoda}).
	Formally, $A_{i,j}$ is equal to
	$\mathscr{S}(\mathscr{M}^{-1}(i),\mathscr{M}^{-1}(j))
	= \mathscr{S}(s_{i,j:j+L-1}, s_{q,z:z+L-1})$.

	$A$ is then, quite simply, a similarity matrix
	for all $N$ windows based on the similarity
	function $\mathscr{S}$.  
	In most cases, $\mathscr{S}$
	is commutative (and the $A$ matrix is symmetric);
	however, this is not a requirement.

    \subsection{Clustering phase}
	The purpose of the clustering phase is to
	use the similarity matrix $A$ to group
	similar windows in clusters.
	These clusters will become
	``elementary motifs'' from which the final,
	maximal motifs will be constructed.  

	We define a clustering function $\mathscr{C}(A)
	= c^L = \{c_1^{L}, c_2^{L},\ldots, c_Z^{L}\}$
	where each $c_i^L$ is a set of indices in $A$ and
	$c_i^{L}[q]$ is the $q^{th}$ member of $c_i^L$.
	Note that $\mathscr{C}$ can be any function;
	common clustering functions include hierarchical
	clustering, k--nearest--neighbors clustering,
	and many others.  We call each $c_i^L$ an
	``elementary motif'' 
	of length $L$.	We
	note that a clustering function may assign each
	node (window) to one or more groups.
	In the latter case, each $c_i^L$ may have a
	non--null intersection with any $c_j^L$.


    \subsection{Convolution phase}

	The purpose of this phase is to ``stitch together''
	the elementary motifs to generate the final,
	maximal motifs~\citep{rigoutsos1998combinatorial}.
	For the purposes of Gemoda (and consistent with
	the above concept of convolution), we say that a
	motif $h$ of width $\mathscr{W}(h) > L$ meets the
	similarity criterion if for each window of length
	$L$ completely within the motif, all instances
	participate in a cluster together based on
	$\mathscr{S}$ and $\mathscr{C}$.  In this manner,
	we can piece together longer continuous motifs
	from smaller motifs that all meet the similarity
	criterion over windows of length $L$.

	Next we define the ``directed intersection''
	of two elementary motifs, $c_i^L \conv c_j^L
	= c_r^{L+1}$, where $c_r^{L+1}$ is the set of those
	indices $q$ in $c_i^L$ such that $\mathscr{M}(
	\mathscr{M}^{-1}(c_i^{L}[q])+1 )$ is in $c_j^L$.
	That is, $c_r^{L+1}$ is the set of indices in $c_i^L$
	that are located, in the sequences $S$, one
	position earlier than the indices in $c_j^L$.
	$c_r^{L+1}$ is then a motif of length $L+1$.  

	We define the operation ``$\sqsubset$''
	as follows: $c_i^L \conv c_j^L \sqsubset c^{L+1}$ is
	true if the set of indices $c_i^L \conv c_j^L$ is a
	subset or a superset of the indices in any member
	of $c^{L+1}$.  This operation compares a convolved motif of
	length $L+1$ to all previously--convolved motifs of length $L+1$ to
	identify significant overlap: if the list of locations in the
	proposed motif is a superset or subset of the list for 
	any other motif, the
	result of this operation is true.  With this step, Gemoda
	can identify and eliminate redundant and non--maximal motifs.

	If $c_i^L \conv c_j^L \sqsubset c^{L+1}$, then all
	super-- or sub--sets of the proposed convolved
	motifs are removed from $c^{L+1}$; these
	windows are then taken together with the proposed
	motif, and the union of those sets of
	windows is returned to $c^{L+1}$.

	Our objective is to find all the maximal motifs in
	the sequence set using the elementary patterns.
	We do this by performing $c_i^k \conv c_j^k$
	for all $i$ and $j$ at each length $k \ge L$
	until $c^k$ is empty ($\vert c^k \vert = 0$).
	We then define the set of maximal motifs comprising $c^k$
	for all $k$ as $P$, the final set of motifs that
	are returned to the user.  This simple induction
	scheme guarantees that all (and only) the maximal
	motifs are in $P$ given appropriate clustering
	functions (see supplementary materials).


	
\section{Implementation}

	\subsection{Choice of clustering function}
	Gemoda can use any clustering function; however,
	as the size of the input sequence set increases,
	storing the matrix $A$ can become practically
	difficult.  In these cases, it can be easier to store
	true/false
	values in $A$, where the value is true if the
	similarity score between two windows is better than
	a user--defined threshold $g$.	The matrix $A$ can
	then be viewed as an unweighted, undirected graph
	with a vertex for each window and edges between
	those nodes with pairwise similarity scores
	better than $g$ (see Figures~\vref{fig:gemoda}
	and~\vref{fig:graph}).  When constructed as such,
	we have found that clustering functions based on
	finding either cliques\footnote{We define a clique
	as a maximal, fully--connected subgraph.  It may
	be alternatively defined without the requirement
	for maximality, thus making the clusters we
	discuss ``maximal cliques''.  We use the former
	definition for the sake of brevity and clarity when
	discussing the maximality of extending motifs.} or
	connected components (maximal disjoint subgraphs)
	can be effective for motif discovery in diverse
	applications.


	In the case where the clustering function
	$\mathscr{C}(A)$ is chosen such that each $c_i^{L}$ is
	a clique in the $g$--thresholded $A$ matrix, the
	Gemoda algorithm has a guarantee of compositional
	and length maximality, relative to the threshold
	$g$.  That is, Gemoda will discover all motifs
	where each pair of instances has a similarity
	score better than $g$ over every window of size
	$L$, there are no ``missing'' instances having
	this property, and the motif cannot be extended
	either to the left or right (see inductive proof
	in the supplementary material).

	Clique enumeration is
	NP--complete~\citep{garey1979computers,tomita1989optimal};
	however, in practice this complexity is usually
	not an issue because the density (the ratio of
	the number of edges to the number of vertices) of
	graphs is usually low for datasets of nucleotide
	or amino acid sequences (with reasonable choice
	of $g$).

	In the case where the clustering function
	$\mathscr{C}(A)$ is chosen such that each $c_i^{L}$
	is a maximal disjoint subgraph in the $g$--thresholded
	$A$ matrix (i.e., $c^{L}$ represents the connected components of $A$), 
	the computational complexity for
	the clustering phase is significantly less than
	for clique--based clustering.  As well, in the
	case where Gemoda is applied to nucleotide and
	amino acid sequences, the motifs from this connected components
	method may be more
	intuitive than motifs found using clique--based
	clustering.

	The space and time usage of this implementation is not unreasonable.
	In most cases, memory usage is not a limiting factor.  For
	instance, the peak memory usage for a large sequence set containing
	$65,000$ characters is $1$ GB, within the reach of many
	personal computers.  Furthermore, the upcoming examples given in this
	work can all be done in reasonable times.  The amino acid
	sequence example and protein structure example take
	at most tens of seconds on an average desktop PC, while
	the hardest of the DNA sequence examples takes two hours.  These times are
	more than reasonable given the exhaustive guarantees provided by
	the algorithm. 

	%While larger input sets and lower similarity thresholds
	%may extend execution time, we believe that typical problems are
	%in the range of reasonable computation time.

    \begin{comment}
    \subsubsection{Estimation of motif significance}
	The absolute significance of motifs depends
	strongly on the choice of the similarity metric
	and clustering function and is difficult to derive
	\textit{a priori}.  However, for a specific pair
	of similarity metric and clustering function,
	the \emph{relative} significance can be easy
	to calculate.  For the clique--based clustering
	function described above, the relative significance
	can be estimated solely from the matrix $A$
	using a bootstrapping method.  (A description of
	this calculation is included in the supplementary
	materials.)  Such significance calculations are
	equally valid for many different motif discovery
	problems (e.g., nucleotide sequences or protein
	structures) because the calculation method uses
	only the matrix $A$: it is data--type agnostic.
    \end{comment}

    \subsection{Summary of user--supplied parameters} The
	input to Gemoda is a set of sequences (categorical
	or real--valued), a window length, a similarity
	function, and a clustering function.  Various
	clustering functions may require other parameters.
	For example, the clique--finding and connected components
	clustering algorithms discussed above require
	both a threshold parameter $g$ and, optionally,
	a minimal support parameter $k$.  Other parameters
	can be easily incorporated into various clustering
	functions, such as a ``unique support'' parameter
	$p$ that limits returned motifs to those that
	occur in at least $p$ different sequences.

    \subsection{Availability}
	We have written open source programs
	implementing the Gemoda algorithm that are
	publicly available at the following URL:
	\url{http://web.mit.edu/bamel/gemoda}.
	The software includes a number of ``helper'' applications
	for interoperability with common bioinformatics
	tools.	For example, applications are included
	that allow users to model Gemoda's output motifs
	(in the case of nucleotide or amino acid sequences)
	as PSSMs --- using the pftools package available
	via the Prosite database~\citep{hofmann1999prosite}
	--- or as hidden Markov models, using the popular
	HMMer software~\citep{eddy1998profile}.

	The implementation is distributed in two variants,
	each with a different comparison stage of the
	algorithm.  The gemoda--s variant is for motif
	discovery in FastA--formatted text strings,
	typically nucleotide or amino acid sequences.
	The gemoda--r variant is used for motif discovery
	in sets of multi--dimensional, real--valued
	sequences.  The gemoda--s variant is distributed
	with a number of similarity functions based on
	various nucleotide and amino acid substitution
	matrices.  The gemoda--r variant is distributed
	with similarity functions based on the root
	mean square deviation, with options for optimal
	translation and rotation.

    \subsection{Motif Significance}
	Each pair of nodes in a similarity graph can be described with
	two different quantities: $\eta_{i,j}$, the number of neighboring nodes 
	(including each other) that the two nodes have in common, 
	and $\chi_{i,j}$, the number of consecutive windows starting from each 
	of those nodes that are connected to each other.  For instance,
	if window $1$ is similar to windows $1$, $10$, $25$, and $36$,
	and window $10$ is similar to windows $1$, $10$, $25$, and $37$,
	then these two nodes have three neighbor nodes in common and
	$\eta_{1,10} = 3$.  If window $1$ is similar to $10$, $2$ is similar
	to $11$, and $3$ is not similar to $12$, then there are two
	consecutive similar windows and $\chi_{1,10} = 2$.

	By analyzing each node as above, we can accumulate a matrix of
	graph statistics, $\Phi$, such that 
	\begin{equation}
	\phi_{i,j} = \vert \{(x,y) : \eta_{x,y} = i,\chi_{x,y} = j,
	0 \le x,y \leq N\} \vert 
	\end{equation}	
	(where the vertical bars indicate the cardinality of the set, or the
	number of ordered pairs) and 
	\begin{equation}
	\Phi_{i,j} = \sum_{a=i}^\infty \sum_{b=j}^\infty \phi_{a,b}
	\end{equation}
	These statistics can then be used
	in the following calculation for $p_{rel}(q,r)$, the relative likelihood
	of an output motif of length $q$ and support $r$
	given the calculated similarity matrix:
	\begin{equation}
	p_{rel}(q,r) = \binom{N}{r}
	\left[\prod_{i=0}^{r-2} 
	\left(\frac{\Phi_{i,1}}{\Phi_{i,0}}\right)^{r-i-1}\right]
	\left(\frac{\Phi_{r,q-L+1}}{\Phi_{r,1}}\right)
	\end{equation}
	In this equation, the combinatorial factor represents the number of 
	different ways that windows can be sampled in groups of $r$, the
	cumulative product represents the necessary
	conditions for the formation of a clique of length $L$, and the 
	last factor represents the likelihood of extending a clique of support
	$r$ to be length $q$.  In this way, the relative likelihood 
	measure attempts to represent the expected number of motifs of length
	$q$ and support $r$ that would occur at random given the 
	calculated similarity matrix.  Notably, this significance is based
	solely on the similarity matrix $A$, and so it can be used for either
	categorical or real--valued sequence data clustered with the
	clique--finding method.



    \subsection{Proof of exhaustive maximality}
	When using clique--finding as the clustering function, 
	each elementary pattern of length $L$ is a clique
	in our similarity graph.  That is, the elementary pattern is
	a set of windows that are all similar on a pairwise basis and
	there is no other window that can be added to the set.  

	When the algorithm enters the convolution stage, it starts
	by convolving each length $L$ elementary motif
	with all of the others.  An elementary motif that is
	\emph{non--maximal} can be convolved with another elementary
	motif to yield a motif at level $L+1$  that has the
	same cardinality.  All such motifs are marked as non--maximal.
	Those elementary motifs that remain unmarked cannot be extended on
	either side without losing support; since they are cliques
	we know they cannot be made greater in cardinality.
	Thus, all such unmarked cliques of length $L$ can be labeled as 
	maximal motifs and saved for output.  In this way,
	we know that only maximal motifs will be returned to the user, and
	all such motifs will be returned.

	When the ``$\sqsubset$'' operation is performed on two elementary
	motifs of length $L$ that are being convolved, 
	it ensures that no identical 
	motifs of length $L+1$ exist and that no motif of
	length $L+1$ is a subset of any other.  Additionally, since we have 
	exhaustively compared a complete list of elementary motifs, and all such
	motifs are cliques with maximum cardinality, we are certain
	that all possible comparisons between motifs are being made.  That
	is, no unique motifs of length $L+1$ could be created that are
	not subsets of motifs created by our exhaustive comparison.
	Finally, it is important to note that the result of convolving
	any two cliques will always be a clique.  We know this because
	we take the set of all instances that can be extended (so
	the subgraph is maximal) and because all instances that are
	extended were pairwise similar in both windows being convolved
	(thus meeting our definition of similarity over multiple windows).

	Thus, since Gemoda exhaustively generates \emph{all possible}
	cliques of length $L+1$, 
	and every added motif of length $L+1$ is maximal in support,
	we then know with certainty that $c^{L+1}$ is an exhaustive list
	of motifs, or cliques, of length $L+1$.  The induction step
	is then trivial, as setting $L$ equal to $L+1$ at each step 
	gives an exhaustive list of cliques just as when we started
	with $c^L$.  This allows for a
	continual guarantee of exhaustiveness and maximality in output.
	The obvious termination condition for the algorithm is when $\vert c^i
	\vert = 0$.  The pseudocode sketch in~\vref{fig:gemodaProof} faithfully encapsulates
	the inductive algorithm described above.

	
	\begin{figure}[phtb]
	    \begin{comment}
	    \begin{programbox}
		\BEGIN \\%
		    n := 0
		    \WHILE \vert c^n \vert \ne 0 \DO
			\FOR i:=0 \TO \vert c^n \vert \STEP 1 \DO
			    \textrm{ismaximal} := \textrm{true}
			    \FOR j:=0 \TO \vert c^n \vert \STEP 1 \DO
				f := c_i^n \conv c_j^n
				\IF \vert f \vert \ne 0
				    \IF f \sqsubset c^{n+1}  = \textrm{false}
					c^{n+1} := c^{n+1} \cup f
				    \ELSE
					\textrm{choosemaximal}(f,c^{n+1})
				    \FI
				    \IF \vert f \vert = \vert c_i^n \vert
					\textrm{ismaximal} := \textrm{false}
				    \FI
				\FI
			    \OD
			    \IF \textrm{ismaximal} = \textrm{true}
				P := P \cup c_i^n
			    \FI
			\OD
			n := n+1
		    \OD
		\END
	    \end{programbox}
	    \end{comment}
	    \caption{Gemoda pseudocode.
		}\label{fig:gemodaProof}
	\end{figure}


    \subsection{A simple example}
	To demonstrate exactly how the algorithm works, we
	now provide a simple, natural--language example along with
	a description of the actions Gemoda would take at each step.
	Suppose we have a set of three words, 
	\begin{eqnarray*}
		\texttt{MOTIF}\\
		\texttt{MOTOR}\\
		\texttt{POTION}
	\end{eqnarray*}
	and we would like to find the motifs that some of these words
	share in common.  Further, suppose that we are only interested
	in motifs that are at least four letters long and for which at 
	least three of the four letters are ``similar'' between the windows.
	In this example, each word is a sequence, and the parameter $L$ is
	$4$.  Thus, there are $7$ possible windows that are taken 
	sequentially from the three input sequences, numbered as shown in
	figure~\ref{fig:natural}.


	\begin{figure}[p!]
	    \centering
	    \includegraphics[width=\textwidth]{Body/Images-chap3/naturalexample.pdf}
	    \caption{A natural language example illustrating the
	    	steps that Gemoda takes.  In a), we see the three words,
		or sequences, being broken into overlapping windows of 
		four letters each.  Gemoda would then compare each of these
		windows to each other using either of the similarity metrics
		described in the text.  In b), we see the resulting 
		similarity matrix and how it looks when drawn as a graph.
		In the matrix, two nodes are similar by the identity metric
		if there is an ``X'' at their intersection, while they
		are similar by the vowel/consonant metric if there is 
		an ``O'' at their intersection.  Making each window a vertex
		and connecting vertices with an edge if the windows are
		similar, we obtain the graph on the right.  Dotted lines
		indicate similarity by the identity metric, while solid
		lines indicate similarity by the vowel/consonant metric.  In
		this representation, it is clear what the results of both 
		clique--finding and commutative clustering methods will be.
		}\label{fig:natural}
	\end{figure}
	
	If we choose a similarity function based on the identity
	matrix with a threshold of three --- that is, for two windows
	to be similar, at least three letters must be the same ---
	then we find that only the following pairs of windows are similar:
	$(1, 3)$, $(1, 5)$, and $(2, 6)$.  Importantly, we note that though
	window $1$ is similar to both windows $3$ and $5$, windows $3$ and
	$5$ are not similar to each other.

	If, on the other hand, we choose a similarity function based on
	a matrix that distinguishes only between vowels and consonants ---
	that is, any vowel is considered similar to any other vowel, and
	the same goes for any consonant --- we would see different results
	for the same threshold value.  In this case, we would find the
	following set of similarities: $(1, 3)$, $(1, 5)$, $(3, 5)$, 
	$(2, 4)$, $(2, 6)$, and $(4, 6)$. 

	Given these similarity matrices for the different similarity 
	functions, we can now cluster the graphs.  Using the similarity
	matrix from the identity function, a clique--finding algorithm
	would find no cliques larger than size $2$; that is, the only
	cliques that exist are the pairs of similar nodes.  Since window
	$3$ (\texttt{MOTO}) is not similar to window $5$ (\texttt{POTI}),
	they cannot be in the same cluster.

	However, if we use the similarity matrix produced by the weaker
	vowel/consonant function, we will find exactly two cliques of size
	$3$: $\{1, 3, 5\}$ and $\{2, 4, 6\}$.  Though there exist pairs of nodes
	that are similar, none of them is a clique because they are not
	maximal --- that is, each individual pair of nodes that is similar
	(e.g., $(1, 3)$) can have another node added to its set ($5$) without
	violating the pairwise similarity constraint, so only the larger
	set is a clique.

	We also note that applying a connected components clustering function
	to the matrix created by the identity function would give still
	different results.  In the connected components clustering function, the
	fact that windows $3$ and $5$ are not similar would not prevent
	them from being in the same motif; the function finds all disjoint
	subgraphs and defines them as the motifs.  The motifs for such
	a case would be $\{1, 3, 5\}$ and $\{2, 6\}$, which we will call motifs
	$c_0^L$ and $c_1^L$, respectively.

	Finally, we perform the convolution step.  Using the last
	set of motifs described (with connected components clustering and
	the identity similarity function), we perform the convolution
	operation on each ordered pair of motifs; in this case, it means
	performing $c_0^L \conv c_1^L$, $c_1^L \conv c_0^L$,
	$c_1^L \conv c_1^L$, and $c_0^L \conv c_0^L$.
	For the first operation, we find the windows immediately after
	each of the windows in $c_0^L$, which is the set $\{2, 4, 6\}$.
	The intersection of this set with motif $c_1^L$ is the convolved
	motif of length $L+1$, which is $\{2, 6\}$; we can call this
	$c_0^{L+1}$.  In performing $c_1^L
	\conv c_0^L$ and $c_1^L \conv c_1^L$, 
	we note that no windows exist ``after'' windows $2$
	and $6$, because their respective sequences end.  In this case,
	the first set to be intersected is null, so the intersection
	is null.  The final self--convolution operation also yields a null
	set.  We now have only one motif for the new round of convolution,
	$c_0^{L+1}$.  Performing $c_0^{L+1} \conv c_0^{L+1}$ results in
	a null set, meaning that there are no more motifs.  At this point, we
	terminate
	convolution.  It is worth noting that $c_0^L$ is returned as a
	maximal motif because window $4$ cannot be extended, but $c_1^L$ is
	not because all of its instances were convolved in one direction.

	Thus, we get different sets of motifs for different similarity and
	clustering functions.  For identity similarity and clique--finding
	clustering, the final list of motifs is 
	$\{\{\texttt{MOTIF},\texttt{POTIO}\}, \{\texttt{MOTI},\texttt{MOTO}\}\}$.
	For identity similarity and connected components clustering, the final
	list of motifs is
	$\{\{\texttt{MOTIF},\texttt{POTIO}\}, \{\texttt{MOTI},\texttt{MOTO},\texttt{POTI}\}\}$.
	For vowel/consonant similarity and either clustering method, the final
	list of motifs is 
	$\{\{\texttt{MOTIF},\texttt{MOTOR},\texttt{POTIO}\}\}$.



\section{Application}

    In this section, we demonstrate Gemoda's capability by presenting
    several sample applications.  Specifically, we address motif discovery 
    in
    amino acid sequences, in nucleotide sequences, and in protein structures.
    
    As discussed previously, the clustering and convolution stages of
    the Gemoda algorithm are generic --- they are independent of the
    nature of the input data.  However, the comparison stage is
    data--specific.  In what follows, we discuss how the comparison stage
    is changed for each kind of data and outline the types of results Gemoda
    is capable of finding.

    \subsection{Motif discovery in amino acid sequences}

	To use Gemoda to find motifs in amino acid sequences, the
	comparison stage needs to reflect the notion of
	``similarity'' for amino acid sequences.  Specifically, we choose a
	window comparison function $\mathscr{S}$ that returns
	a sequence alignment score, such as
	the bit--score from an amino acid scoring matrix (e.g., the
	popular Blosum matrices~\citep{henikoff1992aminoacid}).

	Here, we demonstrate how Gemoda can be used
	for motif discovery in amino acid sequences
	by ``discovering'' known protein domains
	in the (ppGpp)ase family of enzymes.
	These eight enzymes catalyze the hydrolysis
	of guanosine 3',5'--bis(diphosphate) to
	guanosine 5'--diphosphate (GDP) and are
	classified by the Enzyme Commission (EC) number
	3.1.7.2~\citep{bairoch2000enzyme}. 

	We used Gemoda to identify motifs in these eight
	(ppGpp)ase enzymes using the Blosum--62 scoring
	matrix as the basis of our similarity function
	$\mathscr{S}$ and the clique--based clustering
	function described previously.	Specifically, we
	sought motifs that occurred in all eight sequences,
	were at least 50 residues long, and had a pairwise
	bit--score of at least 50 bits over a window of
	50 residues.

	\begin{figure}[phtb]
	    {\tiny 
		\verbatiminput{Body/Images-chap3/spot.fa}
	    }
	    \caption{Guanosine--3',5'--bis(diphosphate)
		3'--pyrophosphohydrolase (EC 3.1.7.2)
		((ppGpp)ase) (Penta--phosphate
		guanosine-3'--pyrophosphohydrolase)
		sequences.
		}\label{fig:ppGppaseSeqs}
	\end{figure}

	With these parameters, Gemoda discovers four motifs
	in this set of eight sequences; the longest motif,
	with a length of 103 amino acids, is shown in
	Figure~\vref{fig:relaspot} as an alignment of the
	regions that correspond to instances of this motif
	(see also Figure~\vref{fig:graph}).
	A comparison with the known protein domains
	in the NCBI Conserved Domain Database (version
	2.02)~\citep{marchler2003cdd} reveals that this
	motif captures the RelA\_SpoT domain (CDD PSSM--id
	15904). 


	\begin{figure}[phtb]
	    \centering
	    \includegraphics[width=\textwidth]{Body/Images-chap3/gemoda_fig1.pdf}
	    \caption{The RelA\_SpoT motif detected in the 3.1.7.2 enzyme sequences.}\label{fig:relaspot}
	\end{figure}

	\begin{figure}[phtb]
	    \centering
	    \includegraphics[height=5in]{Body/Images-chap3/gemoda_fig2.pdf}
	    \caption{The similarity graph for the 3.1.7.2 enzyme example.
		    (A) is the similarity
		    matrix $A$, which contains one row and column
		    for each window of 50 residues in the
		    set of input sequences.  Entries in the
		    matrix have been thresholded such that
		    pairs of windows that can be aligned
		    with a bit--score greater than 20 are
		    given a black dot and all others
		    are white, producing the familiar
		    dot--plot appearance of the matrix.
		    (B) is a graph representation
		    of $A$.  Each vertex represents a window,
		    and two vertices
		    are connected with an edge if
		    they have a black dot in the top image.
		    The breakout shows a clique of size
		    eight, which represents a set of
		    windows that participate in the motif
		    shown in Figure~\vref{fig:relaspot}.
		    In general, as the bit--score threshold
		    is lowered, the number of edges
		    in the graph increases, making the
		    clustering stage more computationally
		    intensive.	When using clique--based
		    clustering with too small of a threshold, 
		    computational expense may make the problem
		    infeasible.
		    At these thresholds the
		    ``signal'' cannot be distinguished
		    from the ``noise.''  However, with
		    the parameters used in this example,
		    the clustering phase is quite easy,
		    which is intuitive given the number
		    of disjoint subgraphs shown in the
		    bottom image.
		    }\label{fig:graph}
	\end{figure}


	The remaining three motifs are not present in
	the CDD database.  However, further inspection
	using the tools available from the PFAM
	database~\citep{bateman2004pfam} revealed that
	they composed the left, middle, and right regions 
	of the HD domain~\citep{aravind1998hd}. 
	In the SpoT enzymes, this domain has a number
	of insertions and deletions that give rise to
	gaps such that Gemoda identified and reported
	individually the left, middle, and right regions
	of conservation of the HD domain.

	In this example, the Blosum--62 matrix was chosen
	as the similarity metric because it is optimized
	for detecting distant homologs.  The Gemoda
	input parameters $L=50$ and $g=50$ were
	chosen to enforce a one--bit--per--base score,
	which should rise above random ``noise'' since,
	by design, the expected bit--score for two aligned
	amino acids is negative for the Blosum set
	of scoring matrices.

	In order to test the sensitivity of these results
	to noise, we conducted an experiment to determine
	the degree to which these (ppGpp)ase motifs
	could be found if obscured by noise caused by
	adding random spurious sequences to the 8 enzyme
	sequences.  We found that, with the Gemoda input
	parameters described above and using random
	sequences selected from Swiss--Prot (Release
	45.0)~\citep{bairoch2000swiss-prot}, the target
	motifs could be detected in an 8--fold majority
	of spurious sequences.

    \subsection{Motif discovery in nucleotide sequences}

	The discovery of motifs in nucleotide
	sequences is most commonly used in
	the search for \textit{cis}--regulatory
	elements.  The ``Motif Challenge Problem,''
	or the (\textit{l,d})--motif
	problem~\citep{pevzner2000combinatorial}, is an
	abstraction of the \textit{cis}--regulatory element
	discovery problem.

	The original (\textit{l,d})--motif problem
	can be paraphrased as follows:
	\begin{quotation}
	  Within a set of random DNA sequences with i.i.d.\ nucleotides,
	  a parent motif of length $l$ is embedded in each sequence in a
	  random location.  Each time the motif is embedded, it is
	  mutated in $d$ locations.  The (\textit{l,d})--motif problem is to recover
	  the locations of the embeddings, knowing only the parameters $l$
	  and $d$ and that each sequence contains exactly one
	  instance of the motif.
	\end{quotation}

	To a certain extent, this is a somewhat reasonable abstraction
	of the \textit{cis}--regulatory element discovery problem.
	It is also a problem in which false positive motifs are not expected
	to occur by chance: the occurrence of a motif
	with an instance of $d$ or less mutations in each of the $20$ sequences
	has a probability of approximately
	$10^{-15}$ for $l=15$ and $d=4$~\citep{buhler2001finding}. 
	However, the probability is 0.057 that any two windows of length 
	$15$ may be $4$ mutations from a common ancestor.  In a set
	of $20$ sequences each of length $600$, one would then expect
	any given window to be ``similar'' to $663$ other windows purely
	by chance.  With such significant noise obscuring the smaller,
	easily--identifiable signal, this is a difficult problem that,
	as~\citep{pevzner2000combinatorial} pointed out, commonly--used
	tools are incapable of solving accurately.

	Gemoda can provide a direct solution
	to this problem, using clique--based clustering and a comparison
	function based on the identity matrix.  The selection of $g$ is simple,
	as any two motifs with $d$ mutations in $l$ positions must have
	$l-2d$ bases in common.  The only additional step necessary
	is to verify that each of the motif instances identified by 
	Gemoda could have the same ancestor, a simple task.
	We have previously reported~\citep{styczynski2004extension}
	that a data set used by~\citep{pevzner2001dataset} in
	their initial presentation of the challenge
	problem in fact
	had an instance of the parent motif that occurred
	completely by chance and had gone otherwise undetected.  With
	Gemoda, we can easily identify this instance without any
	additional work or manipulation.
	The sequence logo for the planted motif from
	Pevzner and Sze's initial dataset is shown in
	Figure \vref{fig:MCP}; the consensus sequence
	is \texttt{GGCTTTGTAGCTAAC}.  The ``accidental''
	instance of the embedded motif that can be identified
	using
	Gemoda is \texttt{GGATTGATAGCTAAG}.

	Clearly, Gemoda was not originally designed to address the
	(\textit{l,d})--motif problem and, consequently, it 
	does not exploit all of
	the characteristics of the problem to solve it in the
	fastest possible way.  However, it does provide a direct,
	exhaustive solution to the problem that identifies otherwise
	undetectable results.

	\textbf{Identifying natural cis--regulatory elements}
	For some regulons in \textit{E. coli} with mild
	to strong consensus sequences, Gemoda returns
	results that are similar to or improve upon the
	results from commonly--used motif discovery tools.
	For instance, using the set of upstream regions
	($400$ base pairs upstream and $50$ base pairs
	downstream of the translation start site) for
	the $9$ operons believed to be regulated by
	LexA~\citep{salgado2004regulondb}, Gemoda's
	top--scoring motif was used to generate the
	sequence logo found in Figure \vref{fig:MCP}.
	This motif closely matches the literature PWM
	for the LexA binding site and represents 80\%
	of the literature--found binding sites with no
	false positives.  Of course, the difficulty of DNA motif
	discovery problems varies greatly, and this is only one
	straightforward example of such problems.

	\begin{figure}[phtb]
	    \centering
	    \includegraphics[width=0.40\textwidth]{Body/Images-chap3/gemoda_fig3.pdf}
	    \caption{The sequence logo for a) the motif implanted in each 
	        sequence for the (\textit{l,d})--motif problem and b) the
		LexA binding site motif generated from the highest--scoring
		motif returned by Gemoda.}\label{fig:MCP}
	\end{figure}

	The parameters used for this search were $L = 20$, $g = 10$, and
	$k = 6$ with the identity matrix scoring scheme
	and clique--based clustering described above.
	The length was selected based on the knowledge
	that the DNA--binding domain of LexA is a
	helix--turn--helix variant, and so it was likely
	to be a relatively long motif.	The similarity
	threshold was chosen as one--half of $L$, which
	we know from the (\textit{l,d})--motif problem
	ought to be approximately sufficient to prevent
	the graph from being too dense (and thus expensive
	to cluster).  The support threshold was chosen to
	be about two--thirds the total number of sequences,
	allowing for some noise in the data.  Of course,
	the judicious selection of parameters is an
	outstanding problem in binding site discovery.
	It is worth noting that most of these selections
	were simple or intuitive and that there was some tolerance 
	in the results for slight perturbations in parameters.

    \subsection{Motif discovery in protein structures}

	The detection of 3--dimensional motifs in sets
	of protein structures is another 
	problem type that Gemoda can address.
	Often, homologs that are related through a
	distant lineage show little to no
	sequence similarity, particularly at the nucleotide
	level~\citep{eidhammer2000structure}.  However,
	these homologs frequently show conserved tertiary
	structures~\citep{dietmass2001indentification},
	making motif discovery in protein structures often
	revealing in situations where there appears to
	be no similarity at a sequence level. 

	There are a number of well--developed tools for
	the pair--wise comparison of protein structures
	or the comparison of a single protein structure to
	precomputed structural motifs; these have been reviewed
	elsewhere~\citep{eidhammer2000structure}.
	Some of the more popular tools
	include SSAP~\citep{orengo1996ssap},
	VAST~\citep{madej1995threading},
	Dali~\citep{holm1993protein},
	and Mammoth~\citep{ortiz2002mammoth}.
	The Gemoda algorithm, when used for structural
	motif discovery, is most similar to the
	Sarf algorithm~\citep{alexandrov1996sarfing,alexandrov1996analysis}
	and, to a lesser degree, algorithms
	by~\citep{hunter2003protein}
	and~\citep{jonassen2002structure}.
	Conceptually, Gemoda could be thought of as a hybrid
	of the Sarf and Teiresias algorithms, combining
	3--D elementary motif discovery with convolution.
	To the best of our knowledge, Gemoda is the only tool that can
	compare an arbitrary number of protein structures
	simultaneously and produce an exhaustive set of
	maximal motifs.

	To discover motifs in protein structures,
	Gemoda compares $L$--residue windows of the
	proteins' alpha--carbon trace using the
	minimized RMSD similarity metric (one of
	many possible metrics for comparing protein
	sub--structures~\citep{kolodny2005comprehensive}).
	Here we use ``minimized'' to indicate
	that the protein structures are optimally
	super--imposed via rigid--body rotation and
	translation~\citep{horn1987closed,arun1987least};
	occasionally this term is implicit.  Using the
	clique--finding clustering algorithm, Gemoda finds
	motifs that are sets of alpha--carbon traces (in
	a set of protein structures) that can be super--imposed 
	with an RMSD less than $g$ $\AA$ over each window
	of $L$ residues on a
	pair--wise basis.  Similar to the amino acid and
	nucleotide applications of Gemoda, these structural
	motifs are maximal in both length and support.

	Here, we demonstrate how the Gemoda algorithm
	can be used for structural motif discovery by
	``discovering'' the structural homology between the
	human galactose-1-phosphate uridylyltransferase
	(PDB id 1HXQ)~\citep{wedekind1996structure}
	and fragile histidine triad proteins (PDB id
	3FIT)~\citep{lima1997mad}, originally reported
	elsewhere~\citep{holm1997enzyme}.  Using Gemoda,
	we looked for motifs of at least 30 residues,
	occurring in at least three chains, that had a
	pairwise RMSD of 1.5 $\AA$ or less (based on
	superposition of the alpha--carbon backbone)
	over each window of 30 residues.

	This search returns 4 motifs, the longest of
	which is 66 residues (see Figure~\vref{fig:holm}).
	This motif has one embedding in the 3FIT protein
	and two, in different chains, in the 1HXQ protein.
	As shown in the figure, the motif is an alpha helix
	followed by a beta sheet.

	\begin{figure}[phtb]
	    \centering
	    \includegraphics[width=0.90\textwidth]{Body/Images-chap3/gemoda_fig4.pdf}
	    \caption{A motif showing structural conservation between
		the human galactose-1-phosphate uridylyltransferase and
		fragile histidine triad proteins originally reported 
		by~\citet{holm1997enzyme}.  
		The motif, as shown here, was ``discovered''
		using the Gemoda algorithm along with three other, smaller,
		structural motifs that are highly conserved between the
		two proteins.  Notably, the proteins show little sequence
		similarity over the region displayed in the structural
		motif above.  Graphics created using PyMol (DeLano Scientific,
		San Carlos, CA, USA).}\label{fig:holm}
	\end{figure}





\section{Discussion}

Gemoda makes four contributions.  First, the
algorithm is generic in that it is equally applicable to
any variety of sequential data.  Second, Gemoda allows
arbitrary similarity metrics.  In the examples shown here,
we chose relatively simple metrics (scoring matrices and
RMSD--base metrics); however, similarity metrics can
be easily changed or added. For example, in the case of amino acid
sequences, one can easily define hybrid metrics
incorporating primary, secondary, and tertiary structure
features.  In the case of nucleotide sequences,
the metric may be changed to incorporate methylation information.
The third contribution is that Gemoda
returns motifs that are not tied
to any particular motif representation.  In
the case of amino acid sequence motifs, it is easy to model
Gemoda's motifs using regular expressions, hidden Markov
models, or position--specific scoring matrices.  Finally,
when used with the clique--finding clustering algorithm,
Gemoda returns an exhaustive set of maximal motifs.
To the best of our knowledge, Gemoda is the only motif discovery
algorithm incorporating the above features.

As mentioned in the introduction, Gemoda integrates the
best characteristics from a number of previously published
motif and association discovery algorithms.  For
specific problems, Gemoda's performance can be improved 
further, though at the expense of generality.
For example, a window sampling approach such as that used
by Blast~\citep{altschul1997gapped} would be useful in applications where speed is
more important than completeness of results.  For protein
structure comparisons Gemoda could also be altered to use
contact maps like those used by Dali~\citep{holm1993protein}.  The 
convolution stage could also be made faster by using heuristical, 
non--exhaustive convolution methods.  Also, the clustering phase
could be expedited by using approximate clique finding methods.

Futhermore, the Gemoda algorithm could be modified to
find gapped motifs.  As currently formulated, Gemoda
can find motifs with short, fixed length gaps; however
if a gap causes a motif to fail to meet the similarity
threshold during convolution, then it is not extended.
It may be possible to alter the convolution step to
allow for large or variable--length gapped motifs.
Another option is to look for maximal motifs whose offsets
are highly correlated.  Our studies indicate that such
\textit{post hoc} analysis of Gemoda's output can usually
find well--conserved gapped motifs, including those with
variable gap lengths, as was the case for the (ppGpp)ase
example.

Gemoda's generic nature makes it readily applicable for
many problems.  In the protein sequence application,
Gemoda's exhaustive search using a scoring matrix as a
similarity metric identified multiple motifs.  It provided
an accurate representation of these domains in as much
as an eight--fold excess of spurious sequences.  In the
DNA motif discovery application, Gemoda identified an
otherwise unintentional result in a synthetic dataset
and satisfactorily described a motif embedded in a
genomic dataset.  In the protein structure application,
Gemoda demonstrated that it can compare multiple
arbitrary--dimensional structures simultaneously and
return results previously shown in the literature.
Gemoda can also be directly applied to other diverse types
of sequential datasets, or it can be extended to address
problems not yet considered.




